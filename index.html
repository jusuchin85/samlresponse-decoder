<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SAML Response Decoder</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background: #f6f8fa;
      color: #24292f;
    }
    h1 {
      color: #24292f;
      border-bottom: 1px solid #d0d7de;
      padding-bottom: 10px;
    }
    .input-section {
      margin-bottom: 20px;
    }
    label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
    }
    textarea {
      width: 100%;
      height: 150px;
      padding: 12px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      font-family: monospace;
      font-size: 13px;
      resize: vertical;
    }
    textarea:focus {
      outline: none;
      border-color: #0969da;
      box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.15);
    }
    button {
      background: #2da44e;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin-right: 10px;
    }
    button:hover {
      background: #2c974b;
    }
    button.secondary {
      background: #6e7781;
    }
    button.secondary:hover {
      background: #57606a;
    }
    .results {
      display: none;
    }
    .results.show {
      display: block;
    }
    .section {
      background: white;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      margin-bottom: 16px;
      overflow: hidden;
    }
    .section-header {
      background: #f6f8fa;
      padding: 12px 16px;
      font-weight: 600;
      border-bottom: 1px solid #d0d7de;
    }
    .section-body {
      padding: 16px;
    }
    .field {
      margin-bottom: 12px;
    }
    .field:last-child {
      margin-bottom: 0;
    }
    .field-label {
      font-size: 12px;
      color: #57606a;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
      cursor: help;
      transition: color 0.2s ease;
    }
    .field-label[title]:hover {
      color: #0969da;
    }
    .field-value {
      font-family: monospace;
      font-size: 14px;
      word-break: break-all;
      background: #f6f8fa;
      padding: 8px;
      border-radius: 4px;
    }
    .field-value.valid {
      background: #dafbe1;
      color: #1a7f37;
    }
    .field-value.expired {
      background: #ffebe9;
      color: #cf222e;
    }
    .field-value.warning {
      background: #fff8c5;
      color: #9a6700;
    }
    .error {
      background: #ffebe9;
      border: 1px solid #ff8182;
      color: #cf222e;
      padding: 12px 16px;
      border-radius: 6px;
      margin-bottom: 16px;
    }
    .privacy-notice {
      background: #ddf4ff;
      border: 1px solid #54aeff;
      color: #0969da;
      padding: 10px 14px;
      border-radius: 6px;
      margin-bottom: 16px;
      font-size: 14px;
    }
    .help-section {
      background: white;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      margin-bottom: 16px;
    }
    .help-section summary {
      padding: 12px 16px;
      cursor: pointer;
      font-weight: 600;
      user-select: none;
    }
    .help-section summary:hover {
      background: #f6f8fa;
    }
    .help-content {
      padding: 0 16px 16px 16px;
      border-top: 1px solid #d0d7de;
    }
    .help-content h3 {
      font-size: 14px;
      margin: 16px 0 8px 0;
    }
    .help-content ol, .help-content ul {
      margin: 0;
      padding-left: 24px;
    }
    .help-content li {
      margin-bottom: 4px;
      font-size: 14px;
    }
    .help-content code {
      background: #f6f8fa;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 13px;
    }
    .help-content a {
      color: #0969da;
    }
    .footer {
      margin-top: 32px;
      padding: 16px;
      text-align: center;
      font-size: 13px;
      color: #57606a;
      border-top: 1px solid #d0d7de;
    }
    .footer a {
      color: #0969da;
      text-decoration: none;
    }
    .footer a:hover {
      text-decoration: underline;
    }
    .cert-details {
      margin-top: 12px;
    }
    .cert-details summary {
      cursor: pointer;
      font-size: 13px;
      color: #0969da;
      user-select: none;
    }
    .cert-details summary:hover {
      text-decoration: underline;
    }
    .cert-raw {
      margin-top: 8px;
      padding: 12px;
      background: #f6f8fa;
      border-radius: 6px;
      font-size: 11px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .xml-details {
      margin-top: 0;
    }
    .xml-details summary {
      cursor: pointer;
      font-size: 13px;
      color: #0969da;
      user-select: none;
    }
    .xml-details summary:hover {
      text-decoration: underline;
    }
    .xml-container {
      position: relative;
    }
    .copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #24292f;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      z-index: 1;
    }
    .copy-btn:hover {
      background: #32383f;
    }
    .copy-btn.copied {
      background: #2da44e;
    }
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .xml-raw {
      margin-top: 8px;
      padding: 12px;
      background: #f6f8fa;
      border-radius: 6px;
      font-size: 11px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 400px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h1>üîê SAML Response Decoder</h1>
  <p class="privacy-notice">üîí All decoding happens locally in your browser. No data is sent to any server.</p>
  
  <details class="help-section">
    <summary>üìñ How to capture a SAML Response</summary>
    <div class="help-content">
      <h3>Chrome / Edge</h3>
      <ol>
        <li>Open Developer Tools (<code>F12</code> or <code>Cmd+Option+I</code> on Mac)</li>
        <li>Go to the <strong>Network</strong> tab</li>
        <li>Check <strong>Preserve log</strong></li>
        <li>Initiate the SAML login flow (sign in to the app)</li>
        <li>Look for a POST request to a URL containing <code>/saml/consume</code> or <code>/acs</code></li>
        <li>Click on the request, go to the <strong>Payload</strong> tab</li>
        <li>Find the <code>SAMLResponse</code> parameter and copy its value</li>
      </ol>
      <h3>Firefox</h3>
      <ol>
        <li>Open Developer Tools (<code>F12</code> or <code>Cmd+Option+I</code> on Mac)</li>
        <li>Go to the <strong>Network</strong> tab and check <strong>Persist Logs</strong></li>
        <li>Initiate the SAML login flow</li>
        <li>Look for the POST request to the ACS URL</li>
        <li>Click on the request, go to the <strong>Request</strong> tab</li>
        <li>Find and copy the <code>SAMLResponse</code> value</li>
      </ol>
      <h3>Browser Extensions</h3>
      <ul>
        <li><a href="https://addons.mozilla.org/en-US/firefox/addon/saml-tracer/" target="_blank" rel="noopener">SAML-tracer</a> (Firefox)</li>
        <li><a href="https://chrome.google.com/webstore/detail/saml-chrome-panel/paijfdbeoenhembfhkhllainmocckace" target="_blank" rel="noopener">SAML Chrome Panel</a> (Chrome)</li>
      </ul>
    </div>
  </details>

  <div class="input-section">
    <label for="samlInput">Paste Base64-encoded SAML Response:</label>
    <textarea id="samlInput" placeholder="PD94bWwgdmVyc2lvbj0iMS4wIi..."></textarea>
    <div style="margin-top: 12px;">
      <button onclick="decode()">Decode</button>
      <button class="secondary" onclick="clearAll()">Clear</button>
    </div>
  </div>

  <div id="error" class="error" style="display: none;"></div>

  <div id="results" class="results">
    <div class="section" id="rawXmlSection" style="display: none;">
      <div class="section-header">üìÑ Raw XML</div>
      <div class="section-body">
        <details class="xml-details">
          <summary>View decoded SAML Response XML</summary>
          <div class="xml-container">
            <button class="copy-btn" id="copyBtn" aria-label="Copy XML to clipboard"><i class="fa-regular fa-copy"></i> Copy</button>
            <span id="copyStatus" class="visually-hidden" aria-live="polite"></span>
            <pre class="xml-raw" id="xmlRaw"></pre>
          </div>
        </details>
      </div>
    </div>

    <div class="section">
      <div class="section-header">üìú X.509 Certificate</div>
      <div class="section-body">
        <div class="field">
          <div class="field-label" title="The Certificate Authority (CA) or entity that issued this certificate">Issuer</div>
          <div class="field-value" id="certIssuer">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The entity this certificate was issued to (usually the IdP)">Subject</div>
          <div class="field-value" id="certSubject">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The date/time when this certificate became valid">Valid From</div>
          <div class="field-value" id="certNotBefore">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The date/time when this certificate expires ‚Äî needs renewal before this date">Valid Until</div>
          <div class="field-value" id="certNotAfter">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The cryptographic algorithm used to sign this certificate">Signature Algorithm</div>
          <div class="field-value" id="certSigAlg">-</div>
        </div>
        <details class="cert-details" id="certDetails" style="display: none;">
          <summary>View raw certificate (PEM)</summary>
          <pre class="cert-raw" id="certRaw"></pre>
        </details>
      </div>
    </div>

    <div class="section">
      <div class="section-header">üé´ SAML Assertion</div>
      <div class="section-body">
        <div class="field">
          <div class="field-label" title="The format/type of the user identifier (e.g., email, persistent, transient)">NameID Format</div>
          <div class="field-value" id="nameIdFormat">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The unique identifier for the authenticated user">NameID Value</div>
          <div class="field-value" id="nameIdValue">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The SAML Identity Provider that issued this assertion">Issuer</div>
          <div class="field-value" id="samlIssuer">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The URL where this SAML response should be delivered">Destination</div>
          <div class="field-value" id="samlDestination">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The time at which this assertion becomes valid ‚Äî assertion cannot be used before this time">Not Before</div>
          <div class="field-value" id="notBefore">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The exact moment the user authenticated with the IdP (entered password, etc.)">Auth Instant</div>
          <div class="field-value" id="authnInstant">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="The expiry time ‚Äî assertion cannot be used on or after this time">Not On Or After</div>
          <div class="field-value" id="notOnOrAfter">-</div>
        </div>
        <div class="field">
          <div class="field-label" title="Whether the SAML authentication was successful">Status</div>
          <div class="field-value" id="samlStatus">-</div>
        </div>
      </div>
    </div>

    <div class="section" id="attributesSection" style="display: none;">
      <div class="section-header">üè∑Ô∏è SAML Attributes</div>
      <div class="section-body" id="attributesBody">
      </div>
    </div>
  </div>

  <footer class="footer">
    Built by <a href="https://github.com/jusuchin85" target="_blank" rel="noopener">@jusuchin85</a> ¬∑ 2026 ¬∑ Hosted on <a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a> ¬∑ <a href="https://github.com/jusuchin85/samlresponse-decoder" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> Source</a> ¬∑ <a href="https://github.com/jusuchin85/samlresponse-decoder/issues/new" target="_blank" rel="noopener">Report issue</a>
  </footer>

  <script>
    // OID mappings for X.509 certificate parsing
    const OID_MAP = {
      '2.5.4.6': 'C',
      '2.5.4.8': 'ST',
      '2.5.4.7': 'L',
      '2.5.4.10': 'O',
      '2.5.4.11': 'OU',
      '2.5.4.3': 'CN',
      '1.2.840.113549.1.9.1': 'emailAddress'
    };

    const SIG_ALG_MAP = {
      '1.2.840.113549.1.1.5': 'sha1WithRSAEncryption',
      '1.2.840.113549.1.1.11': 'sha256WithRSAEncryption',
      '1.2.840.113549.1.1.12': 'sha384WithRSAEncryption',
      '1.2.840.113549.1.1.13': 'sha512WithRSAEncryption',
      '1.2.840.10045.4.3.2': 'ecdsa-with-SHA256',
      '1.2.840.10045.4.3.3': 'ecdsa-with-SHA384',
      '1.2.840.10045.4.3.4': 'ecdsa-with-SHA512'
    };

    function decode() {
      const input = document.getElementById('samlInput').value.trim();
      const errorDiv = document.getElementById('error');
      const resultsDiv = document.getElementById('results');
      
      errorDiv.style.display = 'none';
      resultsDiv.classList.remove('show');

      if (!input) {
        showError('Please enter a SAML Response');
        return;
      }

      try {
        // Decode base64
        const xmlString = atob(input);
        
        // Parse XML
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
        
        // Check for parse errors
        const parseError = xmlDoc.querySelector('parsererror');
        if (parseError) {
          throw new Error('Invalid XML: ' + parseError.textContent);
        }

        // Extract certificate
        const certElement = xmlDoc.querySelector('X509Certificate');
        if (certElement) {
          const certBase64 = certElement.textContent.replace(/\s/g, '');
          parseCertificate(certBase64);
          displayRawCertificate(certBase64);
        }

        // Extract SAML info
        extractSamlInfo(xmlDoc);

        // Display raw XML
        displayRawXml(xmlString);

        resultsDiv.classList.add('show');
      } catch (e) {
        showError('Failed to decode: ' + e.message);
      }
    }

    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
    }

    function formatUTC(date) {
      if (isNaN(date.getTime())) {
        return 'Invalid Date';
      }
      return date.toUTCString().replace('GMT', 'UTC');
    }

    function displayRawCertificate(base64Cert) {
      // Format as PEM
      const pemLines = ['-----BEGIN CERTIFICATE-----'];
      for (let i = 0; i < base64Cert.length; i += 64) {
        pemLines.push(base64Cert.substring(i, i + 64));
      }
      pemLines.push('-----END CERTIFICATE-----');
      
      document.getElementById('certRaw').textContent = pemLines.join('\n');
      document.getElementById('certDetails').style.display = 'block';
    }

    function displayRawXml(xmlString) {
      // Pretty print XML
      const formatted = formatXml(xmlString);
      document.getElementById('xmlRaw').textContent = formatted;
      document.getElementById('rawXmlSection').style.display = 'block';
      // Reset details state to closed on new decode
      document.querySelector('#rawXmlSection .xml-details').removeAttribute('open');
    }

    function formatXml(xml) {
      if (!xml || xml.length < 3) {
        return xml || '';
      }

      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(xml, 'application/xml');

        // If the XML is not well-formed, DOMParser will create a parsererror element
        const parseError = doc.getElementsByTagName('parsererror')[0];
        if (parseError) {
          // Fall back to the original string if parsing fails
          return xml;
        }

        const indentUnit = '  ';

        function serializeNode(node, depth) {
          const indent = indentUnit.repeat(depth);
          let output = '';

          switch (node.nodeType) {
            case Node.ELEMENT_NODE: {
              let tagOpen = '<' + node.nodeName;
              for (let i = 0; i < node.attributes.length; i++) {
                const attr = node.attributes[i];
                const escapedValue = attr.value
                  .replace(/&/g, '&amp;')
                  .replace(/"/g, '&quot;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/'/g, '&apos;');
                tagOpen += ' ' + attr.name + '="' + escapedValue + '"';
              }

              const children = Array.prototype.slice.call(node.childNodes || []);
              if (children.length === 0) {
                // Self-closing tag for empty elements
                output += indent + tagOpen + '/>\n';
              } else {
                // Determine if there is any element child (for newline placement)
                const hasElementChild = children.some(function(child) {
                  return child.nodeType === Node.ELEMENT_NODE;
                });

                output += indent + tagOpen + '>';
                if (hasElementChild) {
                  output += '\n';
                }

                children.forEach(function(child) {
                  const childText = serializeNode(child, depth + 1);
                  if (childText) {
                    output += childText;
                  }
                });

                if (hasElementChild) {
                  output += indent;
                }
                output += '</' + node.nodeName + '>\n';
              }
              break;
            }
            case Node.TEXT_NODE: {
              const text = node.nodeValue;
              if (text && text.trim() !== '') {
                const escapedText = text.trim()
                  .replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;');
                output += escapedText;
              }
              break;
            }
            case Node.CDATA_SECTION_NODE: {
              const safeCdata = String(node.nodeValue || '').replace(/]]>/g, ']]]]><![CDATA[>');
              output += indent + '<![CDATA[' + safeCdata + ']]>\n';
              break;
            }
            case Node.COMMENT_NODE: {
              let commentText = node.nodeValue || '';
              // XML comments must not contain "--" and must not end with "-"
              commentText = commentText.replace(/--/g, '- -');
              if (commentText.endsWith('-')) {
                commentText += ' ';
              }
              output += indent + '<!--' + commentText + '-->\n';
              break;
            }
            case Node.DOCUMENT_NODE:
            case Node.DOCUMENT_FRAGMENT_NODE: {
              Array.prototype.forEach.call(node.childNodes, function(child) {
                output += serializeNode(child, depth);
              });
              break;
            }
            case Node.PROCESSING_INSTRUCTION_NODE: {
              const target = node.target || '';
              const data = node.nodeValue || '';
              if (target) {
                const content = data ? ' ' + data : '';
                output += indent + '<?' + target + content + '?>\n';
              }
              break;
            }
            default:
              break;
          }

          return output;
        }

        return serializeNode(doc, 0).trim();
      } catch (e) {
        // In case of any unexpected error, return the original XML
        return xml;
      }
    }

    let copyTimeoutId = null;
    
    function copyXml() {
      const xmlContent = document.getElementById('xmlRaw').textContent;
      const statusEl = document.getElementById('copyStatus');
      const btn = document.querySelector('.copy-btn');

      // Clear any pending timeout
      if (copyTimeoutId) {
        clearTimeout(copyTimeoutId);
        copyTimeoutId = null;
      }

      // Check if Clipboard API is available
      if (!navigator.clipboard || !navigator.clipboard.writeText) {
        btn.innerHTML = '<i class="fa-solid fa-xmark"></i> Not supported';
        statusEl.textContent = 'Clipboard API not available. Please copy manually.';
        copyTimeoutId = setTimeout(function() {
          btn.innerHTML = '<i class="fa-regular fa-copy"></i> Copy';
          statusEl.textContent = '';
          copyTimeoutId = null;
        }, 3000);
        return;
      }

      navigator.clipboard.writeText(xmlContent).then(function() {
        btn.innerHTML = '<i class="fa-solid fa-check"></i> Copied!';
        btn.classList.add('copied');
        statusEl.textContent = 'XML copied to clipboard';
        copyTimeoutId = setTimeout(function() {
          btn.innerHTML = '<i class="fa-regular fa-copy"></i> Copy';
          btn.classList.remove('copied');
          statusEl.textContent = '';
          copyTimeoutId = null;
        }, 2000);
      }).catch(function(error) {
        console.error('Failed to copy XML to clipboard:', error);
        btn.innerHTML = '<i class="fa-solid fa-xmark"></i> Failed';
        btn.classList.remove('copied');
        statusEl.textContent = 'Failed to copy XML to clipboard';
        copyTimeoutId = setTimeout(function() {
          btn.innerHTML = '<i class="fa-regular fa-copy"></i> Copy';
          statusEl.textContent = '';
          copyTimeoutId = null;
        }, 2000);
      });
    }

    function parseCertificate(base64Cert) {
      try {
        const binary = atob(base64Cert);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }

        // Parse ASN.1 DER structure
        const cert = parseASN1(bytes, 0);
        
        // Certificate structure: SEQUENCE { tbsCertificate, signatureAlgorithm, signature }
        const tbsCert = cert.children[0];
        const sigAlgSeq = cert.children[1];
        
        // TBS Certificate structure
        let idx = 0;
        
        // Version (optional, tagged [0])
        if (tbsCert.children[idx].tag === 0xA0) {
          idx++;
        }
        
        // Serial number
        idx++;
        
        // Signature algorithm
        idx++;
        
        // Issuer
        const issuer = parseName(tbsCert.children[idx]);
        document.getElementById('certIssuer').textContent = issuer;
        idx++;
        
        // Validity
        const validity = tbsCert.children[idx];
        const notBefore = parseTime(validity.children[0]);
        const notAfter = parseTime(validity.children[1]);
        
        const notBeforeEl = document.getElementById('certNotBefore');
        const notAfterEl = document.getElementById('certNotAfter');
        
        notBeforeEl.textContent = formatUTC(notBefore);
        notAfterEl.textContent = formatUTC(notAfter);
        
        // Check validity
        const now = new Date();
        notBeforeEl.classList.remove('warning', 'valid', 'expired');
        notAfterEl.classList.remove('warning', 'valid', 'expired');
        if (now < notBefore) {
          notBeforeEl.classList.add('warning');
          notBeforeEl.textContent += ' (not yet valid)';
        }
        if (now > notAfter) {
          notAfterEl.classList.add('expired');
          notAfterEl.textContent += ' (EXPIRED)';
        } else {
          notAfterEl.classList.add('valid');
        }
        
        idx++;
        
        // Subject
        const subject = parseName(tbsCert.children[idx]);
        document.getElementById('certSubject').textContent = subject;
        
        // Signature algorithm OID
        const sigAlgOid = parseOID(sigAlgSeq.children[0].bytes);
        document.getElementById('certSigAlg').textContent = SIG_ALG_MAP[sigAlgOid] || sigAlgOid;
        
      } catch (e) {
        console.error('Certificate parsing error:', e);
        document.getElementById('certIssuer').textContent = 'Failed to parse certificate';
      }
    }

    function parseASN1(bytes, offset) {
      const tag = bytes[offset];
      let len = bytes[offset + 1];
      let lenBytes = 1;
      
      if (len & 0x80) {
        const numLenBytes = len & 0x7f;
        len = 0;
        for (let i = 0; i < numLenBytes; i++) {
          len = (len << 8) | bytes[offset + 2 + i];
        }
        lenBytes = 1 + numLenBytes;
      }
      
      const contentStart = offset + 1 + lenBytes;
      const contentBytes = bytes.slice(contentStart, contentStart + len);
      
      const result = {
        tag: tag,
        length: len,
        bytes: contentBytes,
        totalLength: 1 + lenBytes + len
      };
      
      // Parse constructed types (SEQUENCE, SET, or context-specific)
      if ((tag & 0x20) || (tag >= 0xA0 && tag <= 0xAF)) {
        result.children = [];
        let childOffset = 0;
        while (childOffset < len) {
          const child = parseASN1(contentBytes, childOffset);
          result.children.push(child);
          childOffset += child.totalLength;
        }
      }
      
      return result;
    }

    function parseName(nameSeq) {
      const parts = [];
      for (const rdn of nameSeq.children) {
        const atv = rdn.children[0];
        const oid = parseOID(atv.children[0].bytes);
        const value = decodeString(atv.children[1]);
        const name = OID_MAP[oid] || oid;
        parts.push(name + '=' + value);
      }
      return parts.join(', ');
    }

    function parseOID(bytes) {
      const parts = [];
      parts.push(Math.floor(bytes[0] / 40));
      parts.push(bytes[0] % 40);
      
      let value = 0;
      for (let i = 1; i < bytes.length; i++) {
        value = (value << 7) | (bytes[i] & 0x7f);
        if (!(bytes[i] & 0x80)) {
          parts.push(value);
          value = 0;
        }
      }
      return parts.join('.');
    }

    function decodeString(node) {
      const decoder = new TextDecoder('utf-8');
      return decoder.decode(node.bytes);
    }

    function parseTime(node) {
      const str = decodeString(node);
      if (node.tag === 0x17) {
        // UTCTime: YYMMDDHHMMSSZ
        let year = parseInt(str.substr(0, 2));
        year += year >= 50 ? 1900 : 2000;
        const month = parseInt(str.substr(2, 2)) - 1;
        const day = parseInt(str.substr(4, 2));
        const hour = parseInt(str.substr(6, 2));
        const min = parseInt(str.substr(8, 2));
        const sec = parseInt(str.substr(10, 2));
        return new Date(Date.UTC(year, month, day, hour, min, sec));
      } else {
        // GeneralizedTime: YYYYMMDDHHMMSSZ
        const year = parseInt(str.substr(0, 4));
        const month = parseInt(str.substr(4, 2)) - 1;
        const day = parseInt(str.substr(6, 2));
        const hour = parseInt(str.substr(8, 2));
        const min = parseInt(str.substr(10, 2));
        const sec = parseInt(str.substr(12, 2));
        return new Date(Date.UTC(year, month, day, hour, min, sec));
      }
    }

    function extractSamlInfo(xmlDoc) {
      // NameID
      const nameId = xmlDoc.querySelector('NameID') || xmlDoc.querySelector('*|NameID');
      if (nameId) {
        document.getElementById('nameIdFormat').textContent = nameId.getAttribute('Format') || 'Not specified';
        document.getElementById('nameIdValue').textContent = nameId.textContent;
      }

      // Issuer (from Response or Assertion)
      const issuer = xmlDoc.querySelector('Issuer') || xmlDoc.querySelector('*|Issuer');
      if (issuer) {
        document.getElementById('samlIssuer').textContent = issuer.textContent;
      }

      // Destination
      const response = xmlDoc.documentElement;
      const destination = response.getAttribute('Destination');
      if (destination) {
        document.getElementById('samlDestination').textContent = destination;
      }

      // NotBefore and NotOnOrAfter from Conditions
      const conditions = xmlDoc.querySelector('Conditions') || xmlDoc.querySelector('*|Conditions');
      const subjectConfData = xmlDoc.querySelector('SubjectConfirmationData') || xmlDoc.querySelector('*|SubjectConfirmationData');
      
      // NotBefore
      let notBefore = null;
      if (conditions) {
        notBefore = conditions.getAttribute('NotBefore');
      }
      const notBeforeEl = document.getElementById('notBefore');
      notBeforeEl.classList.remove('warning', 'valid', 'expired');
      if (notBefore) {
        const notBeforeDate = new Date(notBefore);
        
        if (isNaN(notBeforeDate.getTime())) {
          notBeforeEl.classList.add('warning');
          notBeforeEl.textContent = 'Invalid date format';
        } else {
          const now = new Date();
          notBeforeEl.textContent = formatUTC(notBeforeDate);
          if (now < notBeforeDate) {
            notBeforeEl.classList.add('warning');
            notBeforeEl.textContent += ' (not yet valid)';
          } else {
            notBeforeEl.classList.add('valid');
          }
        }
      } else {
        notBeforeEl.textContent = '-';
      }

      // AuthnInstant
      const authnStatement = xmlDoc.querySelector('AuthnStatement') || xmlDoc.querySelector('*|AuthnStatement');
      const authnInstantEl = document.getElementById('authnInstant');
      authnInstantEl.classList.remove('warning', 'valid', 'expired');
      if (authnStatement) {
        const authnInstant = authnStatement.getAttribute('AuthnInstant');
        if (authnInstant) {
          const authnDate = new Date(authnInstant);
          if (isNaN(authnDate.getTime())) {
            authnInstantEl.classList.add('warning');
            authnInstantEl.textContent = 'Invalid date format';
          } else {
            authnInstantEl.textContent = formatUTC(authnDate);
          }
        } else {
          authnInstantEl.textContent = '-';
        }
      } else {
        authnInstantEl.textContent = '-';
      }

      // NotOnOrAfter
      let notOnOrAfter = null;
      if (conditions) {
        notOnOrAfter = conditions.getAttribute('NotOnOrAfter');
      }
      if (!notOnOrAfter && subjectConfData) {
        notOnOrAfter = subjectConfData.getAttribute('NotOnOrAfter');
      }
      
      const notOnOrAfterEl = document.getElementById('notOnOrAfter');
      notOnOrAfterEl.classList.remove('warning', 'valid', 'expired');
      if (notOnOrAfter) {
        const expiry = new Date(notOnOrAfter);
        
        if (isNaN(expiry.getTime())) {
          notOnOrAfterEl.classList.add('warning');
          notOnOrAfterEl.textContent = 'Invalid date format';
        } else {
          const now = new Date();
          notOnOrAfterEl.textContent = formatUTC(expiry);
          if (now > expiry) {
            notOnOrAfterEl.classList.add('expired');
            notOnOrAfterEl.textContent += ' (EXPIRED)';
          } else {
            notOnOrAfterEl.classList.add('valid');
            notOnOrAfterEl.textContent += ' (valid)';
          }
        }
      } else {
        notOnOrAfterEl.textContent = '-';
      }

      // Status
      const statusCode = xmlDoc.querySelector('StatusCode') || xmlDoc.querySelector('*|StatusCode');
      if (statusCode) {
        const statusValue = statusCode.getAttribute('Value');
        const statusEl = document.getElementById('samlStatus');
        statusEl.textContent = statusValue;
        if (statusValue.includes('Success')) {
          statusEl.classList.add('valid');
        } else {
          statusEl.classList.add('expired');
        }
      }

      // Attributes
      extractAttributes(xmlDoc);
    }

    function extractAttributes(xmlDoc) {
      const excludedAttributes = [
        'authnmethodsreferences',
        'identityprovider'
      ];

      const attributes = xmlDoc.querySelectorAll('Attribute, *|Attribute');
      const attributesSection = document.getElementById('attributesSection');
      const attributesBody = document.getElementById('attributesBody');
      
      // Clear previous attributes
      attributesBody.innerHTML = '';
      
      if (attributes.length === 0) {
        attributesSection.style.display = 'none';
        return;
      }

      let hasVisibleAttributes = false;
      
      attributes.forEach(attr => {
        const name = attr.getAttribute('Name') || '';
        
        // Get friendly name from the full URL/URN
        let friendlyName = name;
        if (name.includes('/')) {
          friendlyName = name.split('/').pop();
        } else if (name.includes(':')) {
          friendlyName = name.split(':').pop();
        }
        
        // Skip excluded attributes
        if (excludedAttributes.includes(friendlyName.toLowerCase())) {
          return;
        }
        
        const valueEl = attr.querySelector('AttributeValue, *|AttributeValue');
        const value = valueEl ? valueEl.textContent : '';
        
        if (value) {
          hasVisibleAttributes = true;
          const fieldDiv = document.createElement('div');
          fieldDiv.className = 'field';
          fieldDiv.innerHTML = `
            <div class="field-label">${escapeHtml(friendlyName)}</div>
            <div class="field-value">${escapeHtml(value)}</div>
          `;
          attributesBody.appendChild(fieldDiv);
        }
      });

      attributesSection.style.display = hasVisibleAttributes ? 'block' : 'none';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function clearAll() {
      document.getElementById('samlInput').value = '';
      document.getElementById('error').style.display = 'none';
      document.getElementById('results').classList.remove('show');
      
      // Reset all field values and classes
      const fields = document.querySelectorAll('.field-value');
      fields.forEach(f => {
        f.textContent = '-';
        f.classList.remove('valid', 'expired', 'warning');
      });
      
      // Clear and hide attributes section
      document.getElementById('attributesBody').innerHTML = '';
      document.getElementById('attributesSection').style.display = 'none';
      
      // Clear and hide certificate raw section
      document.getElementById('certRaw').textContent = '';
      document.getElementById('certDetails').style.display = 'none';
      
      // Clear and hide raw XML section
      document.getElementById('xmlRaw').textContent = '';
      document.getElementById('rawXmlSection').style.display = 'none';
      
      // Close all <details> elements within the results so they are collapsed next time
      const detailsElements = document.querySelectorAll('#results details');
      detailsElements.forEach(d => d.removeAttribute('open'));
      
      // Clear any pending copy timeout and reset copy button state
      if (copyTimeoutId) {
        clearTimeout(copyTimeoutId);
        copyTimeoutId = null;
      }
      const copyBtn = document.querySelector('.copy-btn');
      if (copyBtn) {
        copyBtn.innerHTML = '<i class="fa-regular fa-copy"></i> Copy';
        copyBtn.classList.remove('copied');
      }
      document.getElementById('copyStatus').textContent = '';
    }

    // Add event listener for copy button
    document.getElementById('copyBtn').addEventListener('click', copyXml);
  </script>
</body>
</html>
